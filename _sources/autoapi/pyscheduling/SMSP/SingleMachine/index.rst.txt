:py:mod:`pyscheduling.SMSP.SingleMachine`
=========================================

.. py:module:: pyscheduling.SMSP.SingleMachine


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pyscheduling.SMSP.SingleMachine.GenerationProtocol
   pyscheduling.SMSP.SingleMachine.GenerationLaw
   pyscheduling.SMSP.SingleMachine.SingleInstance
   pyscheduling.SMSP.SingleMachine.Machine
   pyscheduling.SMSP.SingleMachine.SingleSolution
   pyscheduling.SMSP.SingleMachine.SM_LocalSearch
   pyscheduling.SMSP.SingleMachine.NeighbourhoodGeneration




Attributes
~~~~~~~~~~

.. autoapisummary::

   pyscheduling.SMSP.SingleMachine.Job


.. py:data:: Job
   

   

.. py:class:: GenerationProtocol

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: BASE
      :annotation: = 1

      


.. py:class:: GenerationLaw

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: UNIFORM
      :annotation: = 1

      

   .. py:attribute:: NORMAL
      :annotation: = 2

      


.. py:class:: SingleInstance

   Bases: :py:obj:`pyscheduling.Problem.Instance`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: n
      :annotation: :int

      

   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:
      :abstractmethod:

      Read an instance from a txt file according to the problem's format

      :param path: path to the txt file of type Path from the pathlib module
      :type path: Path

      :raises FileNotFoundError: when the file does not exist

      :rtype: SingleInstance


   .. py:method:: generate_random(protocol: str = None)
      :classmethod:
      :abstractmethod:

      Generate a random instance according to a predefined protocol

      :param protocol: represents the protocol used to generate the instance
      :type protocol: string

      :rtype: SingleInstance


   .. py:method:: to_txt(path: pathlib.Path) -> None
      :abstractmethod:

      Export an instance to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: read_P(content: list[str], startIndex: int)

      Read the Processing time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the processing time table
      :type startIndex: int

      :returns: (Table of processing time, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: read_W(content: list[str], startIndex: int)

      Read the Processing time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the jobs weights table
      :type startIndex: int

      :returns: (Table of jobs weights, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: read_R(content: list[str], startIndex: int)

      Read the release time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the release time table
      :type startIndex: int

      :returns: (Table of release time, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: read_S(content: list[str], startIndex: int)

      Read the Setup time matrix from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the Setup time matrix
      :type startIndex: int

      :returns: (Matrix of setup time, index of the next section of the instance)
      :rtype: (list[list[int]],int)


   .. py:method:: read_D(content: list[str], startIndex: int)

      Read the due time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the due time table
      :type startIndex: int

      :returns: (Table of due time, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: generate_P(protocol: GenerationProtocol, law: GenerationLaw, Pmin: int, Pmax: int)

      Random generation of processing time table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int

      :returns: Table of processing time
      :rtype: list[int]


   .. py:method:: generate_W(protocol: GenerationProtocol, law: GenerationLaw, Wmin: int, Wmax: int)

      Random generation of jobs weights table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param Wmin: Minimal weight
      :type Wmin: int
      :param Wmax: Maximal weight
      :type Wmax: int

      :returns: Table of jobs weights
      :rtype: list[int]


   .. py:method:: generate_R(protocol: GenerationProtocol, law: GenerationLaw, PJobs: list[float], Pmin: int, Pmax: int, alpha: float)

      Random generation of release time table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param PJobs: Table of processing time
      :type PJobs: list[float]
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int
      :param alpha: release time factor
      :type alpha: float

      :returns: release time table
      :rtype: list[int]


   .. py:method:: generate_S(protocol: GenerationProtocol, law: GenerationLaw, PJobs: list[float], gamma: float, Smin: int = 0, Smax: int = 0)

      Random generation of setup time matrix

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param PJobs: Table of processing time
      :type PJobs: list[float]
      :param gamma: Setup time factor
      :type gamma: float
      :param Smin: Minimal setup time . Defaults to 0.
      :type Smin: int, optional
      :param Smax: Maximal setup time. Defaults to 0.
      :type Smax: int, optional

      :returns: Setup time matrix
      :rtype: list[list[int]]


   .. py:method:: generate_D(protocol: GenerationProtocol, law: GenerationLaw, PJobs: list[float], Pmin: int, Pmax: int, due_time_factor: float, RJobs: list[float] = None)

      Random generation of due time table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param PJobs: Table of processing time
      :type PJobs: list[float]
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int
      :param fraction: due time factor
      :type fraction: float

      :returns: due time table
      :rtype: list[int]



.. py:class:: Machine(objective: int = 0, last_job: int = -1, job_schedule: list[Job] = None, wiCi_index: list[int] = None, wiTi_index: list[int] = None)

   .. py:attribute:: objective
      :annotation: :int = 0

      

   .. py:attribute:: last_job
      :annotation: :int

      

   .. py:attribute:: job_schedule
      :annotation: :list[Job]

      

   .. py:attribute:: wiCi_index
      :annotation: :list[int]

      

   .. py:attribute:: wiTi_index
      :annotation: :list[int]

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: __eq__(other)

      Return self==value.


   .. py:method:: copy()


   .. py:method:: toJSON()


   .. py:method:: fromDict(machine_dict)
      :staticmethod:


   .. py:method:: total_weighted_completion_time(instance: SingleInstance, startIndex: int = 0)

      Fills the job_schedule with the correct sequence of start_time and completion_time of each job and returns the total weighted completion time

      :param instance: The instance associated to the machine
      :type instance: SingleInstance
      :param startIndex: The job index the function starts operating from
      :type startIndex: int

      :returns: Total weighted lateness
      :rtype: int


   .. py:method:: total_weighted_completion_time_insert(job: int, pos: int, instance: SingleInstance)

      Computes the machine's total wighted completion time if we insert "job" at "pos" in the machine's job_schedule

      :param job: id of the inserted job
      :type job: int
      :param pos: position where the job is inserted in the machine
      :type pos: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted completion time
      :rtype: int


   .. py:method:: total_weighted_completion_time_remove_insert(pos_remove: int, job: int, pos_insert: int, instance: SingleInstance)

      Computes the machine's total weighted completion time if we remove job at position "pos_remove"
      and insert "job" at "pos" in the machine's job_schedule

      :param pos_remove: position of the job to be removed
      :type pos_remove: int
      :param job: id of the inserted job
      :type job: int
      :param pos_insert: position where the job is inserted in the machine
      :type pos_insert: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted completion time
      :rtype: int


   .. py:method:: total_weighted_completion_time_swap(pos_i: int, pos_j: int, instance: SingleInstance)

      Computes the machine's total weighted completion time if we insert swap jobs at position "pos_i" and "pos_j"
      in the machine's job_schedule
      :param pos_i: position of the first job to be swapped
      :type pos_i: int
      :param pos_j: position of the second job to be swapped
      :type pos_j: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted completion time
      :rtype: int


   .. py:method:: total_weighted_lateness(instance: SingleInstance, startIndex: int = 0)

      Fills the job_schedule with the correct sequence of start_time and completion_time of each job and returns the total weighted lateness

      :param instance: The instance associated to the machine
      :type instance: SingleInstance
      :param startIndex: The job index the function starts operating from
      :type startIndex: int

      :returns: Total weighted lateness
      :rtype: int


   .. py:method:: total_weighted_lateness_insert(job: int, pos: int, instance: SingleInstance)

      Computes the machine's total wighted lateness if we insert "job" at "pos" in the machine's job_schedule
      :param job: id of the inserted job
      :type job: int
      :param pos: position where the job is inserted in the machine
      :type pos: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted lateness
      :rtype: int


   .. py:method:: total_weighted_lateness_remove_insert(pos_remove: int, job: int, pos_insert: int, instance: SingleInstance)

      Computes the machine's total weighted lateness if we remove job at position "pos_remove"
      and insert "job" at "pos" in the machine's job_schedule
      :param pos_remove: position of the job to be removed
      :type pos_remove: int
      :param job: id of the inserted job
      :type job: int
      :param pos_insert: position where the job is inserted in the machine
      :type pos_insert: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted lateness
      :rtype: int


   .. py:method:: total_weighted_lateness_swap(pos_i: int, pos_j: int, instance: SingleInstance)

      Computes the machine's total weighted lateness if we insert swap jobs at position "pos_i" and "pos_j"
      in the machine's job_schedule
      :param pos_i: position of the first job to be swapped
      :type pos_i: int
      :param pos_j: position of the second job to be swapped
      :type pos_j: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: total weighted lateness
      :rtype: int


   .. py:method:: completion_time(instance: SingleInstance, startIndex: int = 0)

      Fills the job_schedule with the correct sequence of start_time and completion_time of each job and returns the maximal completion time

      :param instance: The instance associated to the machine
      :type instance: SingleInstance
      :param startIndex: The job index the function starts operating from
      :type startIndex: int

      :returns: Makespan
      :rtype: int


   .. py:method:: completion_time_insert(job: int, pos: int, instance: SingleInstance)

      Computes the machine's completion time if we insert "job" at "pos" in the machine's job_schedule

      :param job: id of the inserted job
      :type job: int
      :param pos: position where the job is inserted in the machine
      :type pos: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: completion time
      :rtype: int


   .. py:method:: completion_time_remove_insert(pos_remove: int, job: int, pos_insert: int, instance: SingleInstance)

      Computes the machine's completion time if we remove job at position "pos_remove"
      and insert "job" at "pos" in the machine's job_schedule

      :param pos_remove: position of the job to be removed
      :type pos_remove: int
      :param job: id of the inserted job
      :type job: int
      :param pos_insert: position where the job is inserted in the machine
      :type pos_insert: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: Completion time
      :rtype: int


   .. py:method:: completion_time_swap(pos_i: int, pos_j: int, instance: SingleInstance)

      Computes the machine's completion time if we insert swap jobs at position "pos_i" and "pos_j"
      in the machine's job_schedule

      :param pos_i: position of the first job to be swapped
      :type pos_i: int
      :param pos_j: position of the second job to be swapped
      :type pos_j: int
      :param instance: the current problem instance
      :type instance: SingleInstance

      :returns: completion time
      :rtype: int



.. py:class:: SingleSolution(instance: SingleInstance, machine: Machine = None, objective_value: int = 0)

   Bases: :py:obj:`pyscheduling.Problem.Solution`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: machine
      :annotation: :Machine

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: copy()

      Return a copy to the current solution

      :returns: copy of the current solution
      :rtype: Solution


   .. py:method:: __lt__(other)

      Return self<value.


   .. py:method:: wiCi()

      Sets the job_schedule of the machine and affects the total weighted completion time to the objective_value attribute



   .. py:method:: wiTi()

      Sets the job_schedule of the machine and affects the total weighted lateness to the objective_value attribute



   .. py:method:: Cmax()

      Sets the job_schedule of the machine and affects the makespan to the objective_value attribute



   .. py:method:: fix_objective()

      Sets the objective_value attribute of the solution to the objective attribute of the machine



   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:

      Read a solution from a txt file

      :param path: path to the solution's txt file of type Path from pathlib
      :type path: Path

      :rtype: SingleSolution


   .. py:method:: to_txt(path: pathlib.Path) -> None

      Export the solution to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: plot(path: pathlib.Path = None) -> None

      Plot the solution in a gantt diagram


   .. py:method:: is_valid()

      Check if solution respects the constraints



.. py:class:: SM_LocalSearch(methods: list[object] = None, copy_solution: bool = False)

   Bases: :py:obj:`pyscheduling.Problem.LocalSearch`

   .. py:method:: _intra_insertion(solution: SingleSolution, objective: pyscheduling.Problem.Objective)
      :staticmethod:

      Iterates through the job schedule and try to reschedule every job at a better position to improve the solution

      :param solution: solution to improve
      :type solution: SingleSolution
      :param objective: objective to consider
      :type objective: RootProblem.Objective

      :returns: improved solution
      :rtype: SingleSolution


   .. py:method:: _swap(solution: SingleSolution, objective: pyscheduling.Problem.Objective)
      :staticmethod:

      Iterates through the job schedule and choose the best swap between 2 jobs to improve the solution

      :param solution: solution to improve
      :type solution: SingleSolution
      :param objective: objective to consider
      :type objective: RootProblem.Objective

      :returns: improved solution
      :rtype: SingleSolution


   .. py:method:: improve(solution: SingleSolution, objective: pyscheduling.Problem.Objective) -> SingleSolution

      Improves a solution by iteratively calling local search operators

      :param solution: current solution
      :type solution: Solution

      :returns: improved solution
      :rtype: Solution



.. py:class:: NeighbourhoodGeneration

   .. py:method:: random_swap(solution: SingleSolution, objective: pyscheduling.Problem.Objective, force_improve: bool = True)
      :staticmethod:

      Performs a random swap between 2 jobs

      :param solution: Solution to be improved
      :type solution: SingleSolution
      :param objective: objective to consider
      :type objective: RootProblem.Objective
      :param force_improve: If true, to apply the move, it must improve the solution. Defaults to True.
      :type force_improve: bool, optional

      :returns: New solution
      :rtype: SingleSolution


   .. py:method:: passive_swap(solution: SingleSolution, force_improve: bool = True)
      :staticmethod:

      Performs a swap between the 2 less effective jobs in terms of WSPT rule

      :param solution: Solution to be improved
      :type solution: SingleSolution
      :param force_improve: If true, to apply the move, it must improve the solution. Defaults to True.
      :type force_improve: bool, optional

      :returns: New solution
      :rtype: SingleSolution


   .. py:method:: lahc_neighbour(solution: SingleSolution, objective: pyscheduling.Problem.Objective)
      :staticmethod:

      Generates a neighbour solution of the given solution for the lahc metaheuristic

      :param solution_i: Solution to be improved
      :type solution_i: SingleSolution

      :returns: New solution
      :rtype: SingleSolution



