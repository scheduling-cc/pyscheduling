from dataclasses import dataclass
from functools import partial
from typing import Callable

import pyscheduling.JS.JobShop as js
from pyscheduling.core.base_solvers import BaseSolver
from pyscheduling.Problem import Job


@dataclass
class DispatchHeuristic(BaseSolver):

    rule: Callable 
    reverse: bool = False

    def solve(self, instance: js.JobShopInstance):
        """the ordered greedy constructive heuristic to find an initial solution of RmSijkCmax problem minimalizing the factor of (processing time + setup time) of
        jobs in the given order on different machines

        Args:
            instance (JobShopInstance): Instance to be solved by the heuristic
            remaining_jobs (list[int],optional): specific job sequence to consider by the heuristic
            is_random (bool,optional): shuffle the remaining_jobs_list if it's generated by the heuristic

        Returns:
            Problem.SolveResult: the solver result of the execution of the heuristic
        """
        self.notify_on_start()
        solution = js.JobShopSolution(instance)
        jobs_timeline = [(0,0) for i in range(instance.n)]

        remaining_jobs = [  (j, list(range(len(instance.P[j])))) for j in range(instance.n) ]
        sort_rule = partial(self.rule, instance)

        remaining_jobs.sort(key=sort_rule, reverse=self.reverse)

        while len(remaining_jobs) != 0:
            
            # First job in priority, get first operation
            job_tuple = remaining_jobs[0]
            job_id, oper_list = job_tuple
            m_id, proc_time = instance.P[job_id][oper_list[0]]
            oper_idx, last_t = jobs_timeline[job_id]

            start_time, end_time = solution.simulate_insert_last(job_id, oper_idx, last_t)
            
            curr_machine = solution.machines[m_id]
            curr_machine.job_schedule.append( Job(job_id, start_time, end_time) )
            curr_machine.last_job = job_id

            # Update job timeline
            jobs_timeline[job_id] = (oper_idx + 1, max(end_time, last_t))

            oper_list.pop(0)
            if len(oper_list) == 0:
                remaining_jobs.pop(0)

            remaining_jobs.sort(key=sort_rule, reverse=self.reverse)

        solution.compute_objective()

        self.notify_on_solution_found(solution)
        self.notify_on_complete()

        return self.solve_result
    