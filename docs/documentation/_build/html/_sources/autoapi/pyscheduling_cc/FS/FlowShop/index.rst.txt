:py:mod:`pyscheduling_cc.FS.FlowShop`
=====================================

.. py:module:: pyscheduling_cc.FS.FlowShop


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pyscheduling_cc.FS.FlowShop.GenerationProtocol
   pyscheduling_cc.FS.FlowShop.GenerationLaw
   pyscheduling_cc.FS.FlowShop.FlowShopInstance
   pyscheduling_cc.FS.FlowShop.Machine
   pyscheduling_cc.FS.FlowShop.FlowShopSolution
   pyscheduling_cc.FS.FlowShop.FS_LocalSearch
   pyscheduling_cc.FS.FlowShop.NeighbourhoodGeneration




Attributes
~~~~~~~~~~

.. autoapisummary::

   pyscheduling_cc.FS.FlowShop.Job


.. py:data:: Job
   

   

.. py:class:: GenerationProtocol

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: VALLADA
      :annotation: = 1

      


.. py:class:: GenerationLaw

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: UNIFORM
      :annotation: = 1

      

   .. py:attribute:: NORMAL
      :annotation: = 2

      


.. py:class:: FlowShopInstance

   Bases: :py:obj:`pyscheduling_cc.Problem.Instance`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: n
      :annotation: :int

      

   .. py:attribute:: m
      :annotation: :int

      

   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:
      :abstractmethod:

      Read an instance from a txt file according to the problem's format

      :param path: path to the txt file of type Path from the pathlib module
      :type path: Path

      :raises FileNotFoundError: when the file does not exist

      :rtype: FlowShopInstance


   .. py:method:: generate_random(protocol: str = None)
      :classmethod:
      :abstractmethod:

      Generate a random instance according to a predefined protocol

      :param protocol: represents the protocol used to generate the instance
      :type protocol: string

      :rtype: FlowShopInstance


   .. py:method:: to_txt(path: pathlib.Path) -> None
      :abstractmethod:

      Export an instance to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: read_P(content: list[str], startIndex: int)

      Read the Processing time matrix from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the processing time matrix
      :type startIndex: int

      :returns: (Matrix of processing time, index of the next section of the instance)
      :rtype: (list[list[int]],int)


   .. py:method:: read_R(content: list[str], startIndex: int)

      Read the release time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the release time table
      :type startIndex: int

      :returns: (Table of release time, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: read_S(content: list[str], startIndex: int)

      Read the Setup time table of matrices from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the Setup time table of matrices
      :type startIndex: int

      :returns: (Table of matrices of setup time, index of the next section of the instance)
      :rtype: (list[list[list[int]]],int)


   .. py:method:: read_D(content: list[str], startIndex: int)

      Read the due time table from a list of lines extracted from the file of the instance

      :param content: lines of the file of the instance
      :type content: list[str]
      :param startIndex: Index from where starts the due time table
      :type startIndex: int

      :returns: (Table of due time, index of the next section of the instance)
      :rtype: (list[int],int)


   .. py:method:: generate_P(protocol: GenerationProtocol, law: GenerationLaw, Pmin: int, Pmax: int)

      Random generation of processing time matrix

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int

      :returns: Matrix of processing time
      :rtype: list[list[int]]


   .. py:method:: generate_R(protocol: GenerationProtocol, law: GenerationLaw, PJobs: list[list[float]], Pmin: int, Pmax: int, alpha: float)

      Random generation of release time table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param PJobs: Matrix of processing time
      :type PJobs: list[list[float]]
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int
      :param alpha: release time factor
      :type alpha: float

      :returns: release time table
      :rtype: list[int]


   .. py:method:: generate_S(protocol: GenerationProtocol, law: GenerationLaw, PJobs: list[list[float]], gamma: float, Smin: int = 0, Smax: int = 0)

      Random generation of setup time table of matrices

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param PJobs: Matrix of processing time
      :type PJobs: list[list[float]]
      :param gamma: Setup time factor
      :type gamma: float
      :param Smin: Minimal setup time . Defaults to 0.
      :type Smin: int, optional
      :param Smax: Maximal setup time. Defaults to 0.
      :type Smax: int, optional

      :returns: Setup time table of matrix
      :rtype: list[list[list[int]]]


   .. py:method:: generate_D(protocol: GenerationProtocol, law: GenerationLaw, Pmin, Pmax)

      Random generation of due time table

      :param protocol: given protocol of generation of random instances
      :type protocol: GenerationProtocol
      :param law: probablistic law of generation
      :type law: GenerationLaw
      :param Pmin: Minimal processing time
      :type Pmin: int
      :param Pmax: Maximal processing time
      :type Pmax: int

      :returns: due time table
      :rtype: list[int]



.. py:class:: Machine(objective: int = 0, last_job: int = -1, job_schedule: list[Job] = None)

   .. py:attribute:: objective
      :annotation: :int = 0

      

   .. py:attribute:: last_job
      :annotation: :int

      

   .. py:attribute:: job_schedule
      :annotation: :list[Job]

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: __eq__(other)

      Return self==value.


   .. py:method:: copy()


   .. py:method:: toJSON()


   .. py:method:: fromDict(machine_dict)
      :staticmethod:


   .. py:method:: completion_time(instance: FlowShopInstance, startIndex: int = 0)

      Fills the job_schedule with the correct sequence of start_time and completion_time of each job and returns the maximal completion time

      :param instance: The instance associated to the machine
      :type instance: SingleInstance
      :param startIndex: The job index the function starts operating from
      :type startIndex: int

      :returns: Makespan
      :rtype: int



.. py:class:: FlowShopSolution(instance: FlowShopInstance = None, machines: list[Machine] = None, job_schedule: list[int] = None, objective_value: int = 0)

   Bases: :py:obj:`pyscheduling_cc.Problem.Solution`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: machines
      :annotation: :list[Machine]

      

   .. py:attribute:: job_schedule
      

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: copy()

      Return a copy to the current solution

      :returns: copy of the current solution
      :rtype: Solution


   .. py:method:: __lt__(other)

      Return self<value.


   .. py:method:: init_machines_schedule()

      Fills the job_schedule of every machine from job_schedule of Solution



   .. py:method:: cmax(start_job_index: int = 0)

      Fills the job_schedule with the correct sequence of start_time and completion_time of each job
       at every machine and returns the maximal completion time which is the completion time of the last machine

      :param start_job_index: starting index to update the job_schedule from for every stage (machine). Defaults to 0.
      :type start_job_index: int, optional


   .. py:method:: idle_time_cmax_insert_last_pos(job_id: int)

      returns start_time and completion_time of job_id if scheduled at the end of job_schedule
      at every stage (machine)

      :param job_id: job to be scheduled at the end
      :type job_id: int

      :returns: start_time of job_id, completion_time of job_id
      :rtype: int, int


   .. py:method:: idle_time()

      returns the idle time of the last machine

      :returns: idle time of the last machine
      :rtype: int


   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:

      Read a solution from a txt file

      :param path: path to the solution's txt file of type Path from pathlib
      :type path: Path

      :rtype: FlowShopSolution


   .. py:method:: to_txt(path: pathlib.Path) -> None

      Export the solution to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: plot(path: pathlib.Path = None) -> None

      Plot the solution in a gantt diagram


   .. py:method:: is_valid()

      Check if solution respects the constraints



.. py:class:: FS_LocalSearch(methods: list[object] = None, copy_solution: bool = False)

   Bases: :py:obj:`pyscheduling_cc.Problem.LocalSearch`


.. py:class:: NeighbourhoodGeneration


