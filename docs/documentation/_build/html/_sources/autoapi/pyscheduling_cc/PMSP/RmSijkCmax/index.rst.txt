:py:mod:`pyscheduling_cc.PMSP.RmSijkCmax`
=========================================

.. py:module:: pyscheduling_cc.PMSP.RmSijkCmax


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pyscheduling_cc.PMSP.RmSijkCmax.RmSijkCmax_Instance
   pyscheduling_cc.PMSP.RmSijkCmax.ExactSolvers
   pyscheduling_cc.PMSP.RmSijkCmax.CSP
   pyscheduling_cc.PMSP.RmSijkCmax.Heuristics
   pyscheduling_cc.PMSP.RmSijkCmax.Metaheuristics
   pyscheduling_cc.PMSP.RmSijkCmax.AntColony




.. py:class:: RmSijkCmax_Instance

   Bases: :py:obj:`pyscheduling_cc.PMSP.ParallelMachines.ParallelInstance`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: P
      :annotation: :list[list[int]]

      

   .. py:attribute:: S
      :annotation: :list[list[list[int]]]

      

   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:

      Read an instance from a txt file according to the problem's format

      :param path: path to the txt file of type Path from the pathlib module
      :type path: Path

      :raises FileNotFoundError: when the file does not exist

      :rtype: RmSijkCmax_Instance


   .. py:method:: generate_random(jobs_number: int, configuration_number: int, protocol: pyscheduling_cc.PMSP.ParallelMachines.GenerationProtocol = ParallelMachines.GenerationProtocol.VALLADA, law: pyscheduling_cc.PMSP.ParallelMachines.GenerationLaw = ParallelMachines.GenerationLaw.UNIFORM, Pmin: int = -1, Pmax: int = -1, Gamma: float = 0.0, Smin: int = -1, Smax: int = -1, InstanceName: str = '')
      :classmethod:

      Random generation of RmSijkCmax problem instance

      :param jobs_number: number of jobs of the instance
      :type jobs_number: int
      :param configuration_number: number of machines of the instance
      :type configuration_number: int
      :param protocol: given protocol of generation of random instances. Defaults to ParallelMachines.GenerationProtocol.VALLADA.
      :type protocol: ParallelMachines.GenerationProtocol, optional
      :param law: probablistic law of generation. Defaults to ParallelMachines.GenerationLaw.UNIFORM.
      :type law: ParallelMachines.GenerationLaw, optional
      :param Pmin: Minimal processing time. Defaults to -1.
      :type Pmin: int, optional
      :param Pmax: Maximal processing time. Defaults to -1.
      :type Pmax: int, optional
      :param Gamma: Setup time factor. Defaults to 0.0.
      :type Gamma: float, optional
      :param Smin: Minimal setup time. Defaults to -1.
      :type Smin: int, optional
      :param Smax: Maximal setup time. Defaults to -1.
      :type Smax: int, optional
      :param InstanceName: name to give to the instance. Defaults to "".
      :type InstanceName: str, optional

      :returns: the randomly generated instance
      :rtype: RmSijkCmax_Instance


   .. py:method:: to_txt(path: pathlib.Path) -> None

      Export an instance to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: init_sol_method()


   .. py:method:: get_objective()


   .. py:method:: lower_bound()

      Computes the lower bound of maximal completion time of the instance
      by dividing the sum of minimal completion time between job pairs on the number of machines

      :returns: Lower Bound of maximal completion time
      :rtype: int



.. py:class:: ExactSolvers

   .. py:method:: csp(instance, **kwargs)
      :staticmethod:



.. py:class:: CSP

   .. py:class:: MyCallback(stop_times=[300, 600, 3600, 7200])

      Bases: :py:obj:`docplex.cp.solver.cpo_callback.CpoCallback`

      A callback used to log the value of cmax at different timestamps

      :param CpoCallback: Inherits from CpoCallback
      :type CpoCallback: _type_

      .. py:method:: invoke(solver, event, jsol)

         Notify the callback about a solver event.

         This method is called every time an event is notified by the CPO solver.
         Associated to the event, the solver information is provided as a an object of class
         class:`~docplex.cp.solution.CpoSolveResult` that is instantiated with information available at this step.

         :param solver: Originator CPO solver (object of class :class:`~docplex.cp.solver.solver.CpoSolver`)
         :param event: Event id, string with value in ALL_CALLBACK_EVENTS
         :param sres: Solver data, object of class :class:`~docplex.cp.solution.CpoSolveResult`



   .. py:attribute:: CPO_STATUS
      

      

   .. py:method:: _transform_csp_solution(msol, T_ki, instance)
      :staticmethod:

      Transforms cp optimizer interval variable into a solution

      :param msol (): CPO solution
      :param T_ki: Interval variables represening jobs
      :type T_ki: list[list[interval_var]]
      :param instance: instance corresponding to the solution
      :type instance: RmSijkCmax_Instance

      :returns: cpoptimizer's solution
      :rtype: ParallelSolution


   .. py:method:: solve(instance, **kwargs)
      :staticmethod:

      Returns the solution using the Cplex - CP optimizer solver

      :param instance: Instance object to solve
      :type instance: Instance
      :param log_path: Path to the log file to output cp optimizer log. Defaults to None to disable logging.
      :type log_path: str, optional
      :param time_limit: Time limit for executing the solver. Defaults to 300s.
      :type time_limit: int, optional
      :param threads: Number of threads to set for cp optimizer solver. Defaults to 1.
      :type threads: int, optional

      :returns: The object represeting the solving process result
      :rtype: SolveResult



.. py:class:: Heuristics

   .. py:method:: constructive(instance: RmSijkCmax_Instance)
      :staticmethod:

      the greedy constructive heuristic to find an initial solution of RmSijkCmax problem minimalizing the factor of (processing time + setup time) of the job to schedule at a given time

      :param instance: Instance to be solved by the heuristic
      :type instance: RmSijkCmax_Instance

      :returns: the solver result of the execution of the heuristic
      :rtype: Problem.SolveResult


   .. py:method:: list_heuristic(instance: RmSijkCmax_Instance, rule=1, decreasing=False)
      :staticmethod:

      list_heuristic gives the option to use different rules in order to consider given factors in the construction of the solution

      :param instance: Instance to be solved by the heuristic
      :type instance: _type_
      :param rule: ID of the rule to follow by the heuristic. Defaults to 1.
      :type rule: int, optional
      :param decreasing: _description_. Defaults to False.
      :type decreasing: bool, optional

      :returns: the solver result of the execution of the heuristic
      :rtype: Problem.SolveResult


   .. py:method:: all_methods()
      :classmethod:

      returns all the methods of the given Heuristics class

      :returns: list of functions
      :rtype: list[object]



.. py:class:: Metaheuristics

   Bases: :py:obj:`pyscheduling_cc.PMSP.PM_methods.Metaheuristics_Cmax`

   .. py:method:: antColony(instance: RmSijkCmax_Instance, **data)
      :staticmethod:

      Returns the solution using the ant colony algorithm

      :param instance: Instance to be solved
      :type instance: RmSijkCmax_Instance

      :returns: the solver result of the execution of the metaheuristic
      :rtype: Problem.SolveResult



.. py:class:: AntColony(instance: RmSijkCmax_Instance, n_ants: int = 60, n_best: int = 1, n_iterations: int = 100, alpha=1, beta=1, phi: float = 0.081, evaporation: float = 0.01, q0: float = 0.5, best_ants: int = 10, pheromone_init=10)

   Bases: :py:obj:`object`

   .. py:method:: solve()

      Main method used to solve the problem and call the different steps

      :returns: Object containing the solution and useful metrics
      :rtype: SolveResult


   .. py:method:: init_graph()

      Initialize the two stage graph with initial values of pheromone

      :returns: list of the two stage graph consisting of np.array elements
      :rtype: list[np.array]


   .. py:method:: spread_pheronome_global(all_solutions: list[pyscheduling_cc.PMSP.ParallelMachines.ParallelSolution])

      Update pheromone levels globally after finding new solutions

      :param all_solutions: list of generated solutions
      :type all_solutions: list[RmSijkCmax_Solution]


   .. py:method:: improve_best_ants(all_solutions)

      Apply local search to the best solution

      :param all_solutions: list of all generated solutions
      :type all_solutions: _type_

      :returns: list of updated solutions
      :rtype: list[RmSijkCmax_Solution]


   .. py:method:: gen_all_paths()

      Calls the gen_path function to generate all solutions from ants paths

      :returns: list of new solutions
      :rtype: list[RmSijkCmax_Solution]


   .. py:method:: gen_path()

      Generate one new solution from one ant's path, it calls the two stages: affect_tasks and sequence_tasks

      :returns: new solution from ant's path
      :rtype: RmSijkCmax_Solution


   .. py:method:: affect_tasks()

      Generates an affectation from the first stage graph and the path the ant went through

      :returns: List of tasks inside each machine
      :rtype: list[list[int]]


   .. py:method:: sequence_tasks(affectation)

      Uses the affectation from stage 1 to sequence tasks inside machines using stage 2 of the graph

      :param affectation: affectation to machines
      :type affectation: list[list[int]]

      :returns: complete solution of one ant
      :rtype: ParallelMachines.ParallelSolution


   .. py:method:: pick_task(prev, m, pheromone, affected_tasks, visited)

      Select a task to affect according to pheromone levels and the graph's state

      :param prev: previous segment in the graph
      :type prev: int
      :param m: number of machines
      :type m: int
      :param pheromone: pheromone levels
      :type pheromone: np.array
      :param affected_tasks: list of affected tasks
      :type affected_tasks: list
      :param visited: list of visited segments
      :type visited: list

      :returns: next task to affect
      :rtype: int


   .. py:method:: reinit_graph()

      Reinitialize the graph's pheromone levels when the premature convergence is detected




