:py:mod:`pyscheduling.PMSP.RmriSijkCmax`
========================================

.. py:module:: pyscheduling.PMSP.RmriSijkCmax


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pyscheduling.PMSP.RmriSijkCmax.RmriSijkCmax_Instance
   pyscheduling.PMSP.RmriSijkCmax.ExactSolvers
   pyscheduling.PMSP.RmriSijkCmax.CSP
   pyscheduling.PMSP.RmriSijkCmax.MILP
   pyscheduling.PMSP.RmriSijkCmax.Heuristics
   pyscheduling.PMSP.RmriSijkCmax.Metaheuristics
   pyscheduling.PMSP.RmriSijkCmax.GeneticAlgorithm




.. py:class:: RmriSijkCmax_Instance

   Bases: :py:obj:`pyscheduling.PMSP.ParallelMachines.ParallelInstance`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: P
      :annotation: :list[list[int]]

      

   .. py:attribute:: S
      :annotation: :list[list[list[int]]]

      

   .. py:attribute:: R
      :annotation: :list[int]

      

   .. py:method:: read_txt(path: pathlib.Path)
      :classmethod:

      Read an instance from a txt file according to the problem's format

      :param path: path to the txt file of type Path from the pathlib module
      :type path: Path

      :raises FileNotFoundError: when the file does not exist

      :rtype: RmSijkCmax_Instance


   .. py:method:: generate_random(jobs_number: int, configuration_number: int, protocol: pyscheduling.PMSP.ParallelMachines.GenerationProtocol = ParallelMachines.GenerationProtocol.VALLADA, law: pyscheduling.PMSP.ParallelMachines.GenerationLaw = ParallelMachines.GenerationLaw.UNIFORM, Pmin: int = -1, Pmax: int = -1, Alpha: float = 0.0, Gamma: float = 0.0, Smin: int = -1, Smax: int = -1, InstanceName: str = '')
      :classmethod:

      Random generation of RmSijkCmax problem instance

      :param jobs_number: number of jobs of the instance
      :type jobs_number: int
      :param configuration_number: number of machines of the instance
      :type configuration_number: int
      :param protocol: given protocol of generation of random instances. Defaults to ParallelMachines.GenerationProtocol.VALLADA.
      :type protocol: ParallelMachines.GenerationProtocol, optional
      :param law: probablistic law of generation. Defaults to ParallelMachines.GenerationLaw.UNIFORM.
      :type law: ParallelMachines.GenerationLaw, optional
      :param Pmin: Minimal processing time. Defaults to -1.
      :type Pmin: int, optional
      :param Pmax: Maximal processing time. Defaults to -1.
      :type Pmax: int, optional
      :param Alpha: Release time factor. Defaults to 0.0.
      :type Alpha: float,optional
      :param Gamma: Setup time factor. Defaults to 0.0.
      :type Gamma: float, optional
      :param Smin: Minimal setup time. Defaults to -1.
      :type Smin: int, optional
      :param Smax: Maximal setup time. Defaults to -1.
      :type Smax: int, optional
      :param InstanceName: name to give to the instance. Defaults to "".
      :type InstanceName: str, optional

      :returns: the randomly generated instance
      :rtype: RmSijkCmax_Instance


   .. py:method:: to_txt(path: pathlib.Path) -> None

      Export an instance to a txt file

      :param path: path to the resulting txt file
      :type path: Path


   .. py:method:: init_sol_method()


   .. py:method:: get_objective()


   .. py:method:: lower_bound()

      Computes the lower bound of maximal completion time of the instance
      by dividing the sum of minimal completion time between job pairs on the number of machines

      :returns: Lower Bound of maximal completion time
      :rtype: int



.. py:class:: ExactSolvers

   .. py:method:: csp(instance, **kwargs)
      :staticmethod:


   .. py:method:: milp(instance, **kwargs)
      :staticmethod:



.. py:class:: CSP

   .. py:class:: MyCallback(stop_times=[300, 600, 3600, 7200])

      Bases: :py:obj:`docplex.cp.solver.cpo_callback.CpoCallback`

      CPO callback allows to be warned directly by the solver engine about different solving steps.

      This class is an 'abstract' class that must be extended by actual listener implementation.
      All method of this class are empty.

      *New in version 2.10.*

      .. py:method:: invoke(solver, event, jsol)

         Notify the callback about a solver event.

         This method is called every time an event is notified by the CPO solver.
         Associated to the event, the solver information is provided as a an object of class
         class:`~docplex.cp.solution.CpoSolveResult` that is instantiated with information available at this step.

         :param solver: Originator CPO solver (object of class :class:`~docplex.cp.solver.solver.CpoSolver`)
         :param event: Event id, string with value in ALL_CALLBACK_EVENTS
         :param sres: Solver data, object of class :class:`~docplex.cp.solution.CpoSolveResult`



   .. py:attribute:: CPO_STATUS
      

      

   .. py:method:: _csp_transform_solution(msol, X_ij, instance)
      :staticmethod:


   .. py:method:: solve(instance, **kwargs)
      :staticmethod:

      Returns the solution using the Cplex - CP optimizer solver

      :param instance: Instance object to solve
      :type instance: Instance
      :param log_path: Path to the log file to output cp optimizer log. Defaults to None to disable logging.
      :type log_path: str, optional
      :param time_limit: Time limit for executing the solver. Defaults to 300s.
      :type time_limit: int, optional
      :param threads: Number of threads to set for cp optimizer solver. Defaults to 1.
      :type threads: int, optional

      :returns: The object represeting the solving process result
      :rtype: SolveResult



.. py:class:: MILP

   .. py:attribute:: GUROBI_STATUS
      

      

   .. py:method:: format_matrices(instance)
      :staticmethod:

      Formats the matrices to add the dummy job and fix indices according to mip model

      :param instance: instance to be solved
      :type instance: RmSijkCmax_Instance

      :returns: setup times matrices, processing times matrix
      :rtype: (list[list[list[int]]], list[list[int]])


   .. py:method:: build_callback(mycallback, stop_times=[300, 600, 3600, 7200])
      :staticmethod:


   .. py:method:: mycallback(model, where)
      :staticmethod:


   .. py:method:: transform_solution(Y_ij, C_j, instance)
      :staticmethod:


   .. py:method:: solve(instance, **kwargs)
      :staticmethod:

      Returns the solution using the MILP solver

      :param instance: Instance object to solve
      :type instance: Instance
      :param log_path: Path to the log file to output gurobi log. Defaults to None to disable logging.
      :type log_path: str, optional
      :param time_limit: Time limit for executing the solver. Defaults to 300s.
      :type time_limit: int, optional
      :param threads: Number of threads to set for gurobi solver. Defaults to 1.
      :type threads: int, optional

      :returns: The object represeting the solving process result
      :rtype: SolveResult



.. py:class:: Heuristics

   .. py:method:: constructive(instance: RmriSijkCmax_Instance)
      :staticmethod:

      the greedy constructive heuristic to find an initial solution of RmSijkCmax problem minimalizing the factor of (processing time + setup time) of the job to schedule at a given time

      :param instance: Instance to be solved by the heuristic
      :type instance: RmriSijkCmax_Instance

      :returns: the solver result of the execution of the heuristic
      :rtype: Problem.SolveResult


   .. py:method:: ordered_constructive(instance: RmriSijkCmax_Instance, remaining_jobs_list=None, is_random: bool = False)
      :staticmethod:

      the ordered greedy constructive heuristic to find an initial solution of RmSijkCmax problem minimalizing the factor of (processing time + setup time) of
      jobs in the given order on different machines

      :param instance: Instance to be solved by the heuristic
      :type instance: RmriSijkCmax_Instance
      :param remaining_jobs_list: specific job sequence to consider by the heuristic
      :type remaining_jobs_list: list[int],optional
      :param is_random: shuffle the remaining_jobs_list if it's generated by the heuristic
      :type is_random: bool,optional

      :returns: the solver result of the execution of the heuristic
      :rtype: Problem.SolveResult


   .. py:method:: list_heuristic(instance: RmriSijkCmax_Instance, rule: int = 1, decreasing: bool = False)
      :staticmethod:

      list_heuristic gives the option to use different rules in order to consider given factors in the construction of the solution

      :param instance: Instance to be solved by the heuristic
      :type instance: RmriSijkCmax_Instance
      :param rule: ID of the rule to follow by the heuristic. Defaults to 1.
      :type rule: int, optional
      :param decreasing: _description_. Defaults to False.
      :type decreasing: bool, optional

      :returns: the solver result of the execution of the heuristic
      :rtype: Problem.SolveResult


   .. py:method:: all_methods()
      :classmethod:

      returns all the methods of the given Heuristics class

      :returns: list of functions
      :rtype: list[object]



.. py:class:: Metaheuristics

   Bases: :py:obj:`pyscheduling.PMSP.PM_methods.Metaheuristics_Cmax`

   .. py:method:: GA(instance: RmriSijkCmax_Instance, **kwargs)
      :staticmethod:

      Returns the solution using the genetic algorithm

      :param instance: Instance to be solved
      :type instance: RmSijkCmax_Instance

      :returns: the solver result of the execution of the metaheuristic
      :rtype: Problem.SolveResult



.. py:class:: GeneticAlgorithm

   .. py:method:: solve(instance: RmriSijkCmax_Instance, pop_size=50, p_cross=0.7, p_mut=0.5, p_ls=1, pressure=30, n_iterations=100)
      :staticmethod:


   .. py:method:: generate_population(instance: RmriSijkCmax_Instance, pop_size=40, LS=True)
      :staticmethod:


   .. py:method:: selection(population, pressure)
      :staticmethod:


   .. py:method:: crossover(instance: RmriSijkCmax_Instance, parent_1, parent_2)
      :staticmethod:


   .. py:method:: mutation(instance: RmriSijkCmax_Instance, child: pyscheduling.PMSP.ParallelMachines.ParallelSolution)
      :staticmethod:


   .. py:method:: complete_solution(instance: RmriSijkCmax_Instance, parent, child: pyscheduling.PMSP.ParallelMachines.ParallelSolution)
      :staticmethod:


   .. py:method:: replacement(population, child)
      :staticmethod:



